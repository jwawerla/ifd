/***************************************************************************
 * Project: IFD                                                            *
 * Author:  Jens Wawerla (jwawerla@sfu.ca)                                 *
 * $Id: $
 ***************************************************************************
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 **************************************************************************/
#include "patch.h"
#include "patchvis.h"
#include <assert.h>


//-----------------------------------------------------------------------------
int stgUpdate( Stg::Model* mod, CPatch* patch )
{
  patch->update();
  return 0; // ok
}
//-----------------------------------------------------------------------------
/*
CPatch::CPatch( CPose2d pose, std::string name ) : IPatch(),
    MIN_PUCK_PUCK_SPACING( 0.6 ),
    MIN_PUCK_ROBOT_SPACING( 1.5 )
{
  mPatchManager = CPatchManager::getInstance( NULL );
  mPose = pose;
  mName = name;
  mRadius = 2.5;
  mLastPuckPlacedTimestamp = 0.0;

  mPatchManager->registerPatch( this );
}
*/
//-----------------------------------------------------------------------------
CPatch::CPatch( Stg::Model* mod ) : IPatch(),
    MIN_PUCK_PUCK_SPACING( 0.6 ),
    MIN_PUCK_ROBOT_SPACING( 3.5 )
{
  Stg::Pose pose;
  int tmpInt;

  assert( mod );
  mPatchManager = CPatchManager::getInstance( mod->GetWorld() );
  mPatchManager->registerPatch( this );
  mStgModel = mod;
  pose = mStgModel->GetPose();
  mPose.mX = pose.x;
  mPose.mY = pose.y;

  mLastPuckPlacedTimestamp = 0.0;
  mName = mStgModel->Token();
  mStgModel->AddUpdateCallback(( Stg::stg_model_callback_t ) stgUpdate, this );
  mStgModel->Subscribe();

  if ( !  mStgModel->GetPropertyFloat( "puck_rate", &mPuckRate, 0.0 ) )
    PRT_WARN1( "Puck renewal rate not found %s\n",
               mStgModel->Token() );

  if ( !  mStgModel->GetPropertyInt( "max_pucks", &mMaxPucks, 0 ) )
    PRT_WARN1( "Maximal number of pucks in patch not found %s\n",
               mStgModel->Token() );

  if ( !  mStgModel->GetPropertyFloat( "radius", &mRadius, 0.0 ) )
    PRT_WARN1( "Radius not found %s\n",
               mStgModel->Token() );

  if ( !  mStgModel->GetPropertyInt( "init_empty", &tmpInt, 1 ) )
    PRT_WARN1( "Init empty flag  not found %s\n",
               mStgModel->Token() );
  mFgInitEmpty = tmpInt;

// mStgModel->Init();
  createPucks();
  mFgFirstRun = true;

  mPuckRate = 0.000000001;
 

  //mod->AddVisualizer( new CPatchVis( mRadius ), true );
}
//-----------------------------------------------------------------------------
CPatch::~CPatch()
{
  printf( "CPatch::~CPatch() %s\n", mName.c_str() );
}
//-----------------------------------------------------------------------------
void CPatch::createPucks()
{

  char name[25];
  tPuck puck;
  Stg::Color color( 0, 0, 1 );
  Stg::Geom geom;
  Stg::World* world;
  world = mStgModel->GetWorld();
  assert( world );

  //PRT_MSG1( 4, "Generating %d pucks ", mMaxPucks );
  //printf("Generating %d pucks \n", mMaxPucks);
  for ( int i = 0; i < mMaxPucks; i++ ) {
    puck.mod = world->CreateModel( mStgModel, "model" );
    //puck.mod = world->CreateModel( NULL, "model" );
    assert( puck.mod );
    geom = puck.mod->GetGeom();
    geom.size.x = 0.1;
    geom.size.y = 0.1;
    geom.size.z = 0.4;
    puck.mod->SetGeom( geom );
    puck.mod->SetGuiNose( 0 );
    puck.mod->SetGuiMove( 1 );
    puck.mod->SetGuiOutline( 0 );
    puck.mod->SetGuiGrid( 0 );
    puck.mod->SetFiducialReturn( 0 );
    puck.mod->SetLaserReturn( Stg::LaserVisible );
    puck.mod->SetGripperReturn( 1 );
    puck.mod->SetObstacleReturn( 1 );
    puck.mod->SetRangerReturn( 0 );
    setPuckPose( puck.mod, Stg::Pose( 30.0, 30.0, -1.0, 0.0 ) );
    puck.mod->SetColor( color );
    snprintf( name, 25, "puck_%s_%d", mName.c_str(), i );
    puck.mod->SetToken( name );
    puck.mod->SetGuiMove( true );
    mPuckVector.push_back( puck );
    //puck.mod->Init();
    if ( mFgInitEmpty ) {
      mFreePuckList.push_back( puck );
    }
    else {
      placePuck( &puck );
    }

  }
}
//-----------------------------------------------------------------------------
void CPatch::setPuckPose( Stg::Model* mod, Stg::Pose pose )
{
  Stg::Pose stgPose;

  if ( mod ) {

    stgPose = mod->GetPose();
    stgPose.x = pose.x - mPose.mX;
    stgPose.y = pose.y - mPose.mY;
    stgPose.z = pose.z;
    mod->SetPose( stgPose );
  }
}
//-----------------------------------------------------------------------------
void CPatch::update()
{
  float dt;

  if (mFgFirstRun) {
    mFgFirstRun = false;
  }

  dt = ( mStgModel->GetWorld()->SimTimeNow() * 1e-6 ) - mLastPuckPlacedTimestamp;

  if ( dt >= 1.0 / mPuckRate ) {
    if ( mFreePuckList.size() > 0 ) {
      placePuck( &mFreePuckList.front() );
      mFreePuckList.pop_front();
      mLastPuckPlacedTimestamp = mStgModel->GetWorld()->SimTimeNow() * 1e-6;
    }
  }

  printf("freeList %d \n", mFreePuckList.size());
}
//-----------------------------------------------------------------------------
bool CPatch::isPuckIn( CPose2d pose, float radius )
{
  Stg::Pose stgPose;
  CPose2d p;

  for ( unsigned int i = 0; i < mPuckVector.size(); i++ ) {
    stgPose = mPuckVector[i].mod->GetPose();
    p.mX = stgPose.x;
    p.mY = stgPose.y;
    p.mYaw = stgPose.a;
    if ( pose.distance( p ) < radius )
      return true;  // found a puck that is close
  }

  return false; // no puck found with in radius
}
//-----------------------------------------------------------------------------
void CPatch::placePuck( tPuck* puck )
{
  int timeoutCount = 0;
  Stg::Pose pose;
  float x;
  float y;

  do {
    x =  randNo( -mRadius, mRadius );
    y =  randNo( -mRadius, mRadius );
    timeoutCount++;
    if ( timeoutCount > 100 ) {
      PRT_ERR1( "Failed to place pucks in patch %s", mName.c_str() );
      return;
    }
  }
  while ( sqrt( x*x + y*y ) > mRadius ||
          isPuckIn( CPose2d( x, y, 0.0 ), MIN_PUCK_PUCK_SPACING ) ||
          mPatchManager->isRobotIn( CPose2d( mPose.mX + x, mPose.mY + y, 0.0 ),
                                    MIN_PUCK_ROBOT_SPACING ) );

  pose = puck->mod->GetPose();
  pose.x = x;
  pose.y = y;
  puck->mod->SetPose( pose );
}
//-----------------------------------------------------------------------------
CPose2d CPatch::getPose() const
{
  return mPose;
}
//-----------------------------------------------------------------------------
float CPatch::getRadius() const
{
  return mRadius;
}
//-----------------------------------------------------------------------------
void CPatch::puckConsumed( Stg::Model* puck )
{
  if ( puck == NULL )
    return;

  setPuckPose( puck, Stg::Pose( 0.0, 0.0, -1.0, 0.0 ) );

  for ( unsigned int i = 0; i < mPuckVector.size(); i++ ) {
    if ( puck == mPuckVector[i].mod ) {
      mFreePuckList.push_back( mPuckVector[i] );
      break;
    }
  }
}
//-----------------------------------------------------------------------------

